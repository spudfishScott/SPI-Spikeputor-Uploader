
		processor 6502
		seg program
        
		org $9400
        
SPI_SS		equ $C0C1		; SPI card commands (assumes slot 4)
SPI_EXEC	equ $C0C0
SPI_DATA	equ $C0C2
SPI_RESET	equ $C0C3

A2_WAIT		equ $FCA8		; Apple Monitor ROM WAIT function
A2_COUT		equ $FDED		; Apple Monitor ROM Character Out

SP_OUT_BUF_LCK	equ $7FB0		; Spikeputor Output Buffer Lock
SP_OUT_BUF_IDX	equ $7FB2		; Spikeputor Output Buffer Indeces
SP_OUT_BUF	equ $7E00		; Spikeputor Output Buffer

ZP_CMD_PKG	equ $EB			; command and data bytes for spi_cmd
ZP_CMD_STAT	equ $EB			
ZP_DATAH	equ $EC
ZP_DATAL	equ $ED

ZP_LENH		equ $EE			; variables for upload_verify
ZP_LENL		equ $EF
ZP_VERIFY	equ $FF 		; set to $80 to verify, $00 to write
ZP_SRC_PTR	equ $F9

ZP_BUF_IDXH	equ $EE			; variables for monitor_IO
ZP_BUF_IDXL	equ $EF

;-----------------------------------------------------------------------------------------
; Command dispatches
;-----------------------------------------------------------------------------------------
D_SPICmd	JMP SPICmd
D_UploadVerify	JMP UploadVerify
D_Monitor_IO	JMP Monitor_IO

;-----------------------------------------------------------------------------------------
; Execute SPI command. Writes command and two data bytes. Reads status and two data bytes.
; Set ZP_CMD_PKG before calling, A and X scrambled.
;-----------------------------------------------------------------------------------------
		SUBROUTINE
SPICmd		ldx #$00
        	lda #$01		; use SPI channel 0 (set bit 0)
        	sta SPI_SS		; begin SPI transaction
                lda #$01
                jsr A2_WAIT		; wait for INIT puse to finish (30 uS)
.nextByte	lda ZP_CMD_PKG,x	; load byte (one command byte, two data bytes)
                sta SPI_DATA		; store in SPI data latch
                sta SPI_EXEC		; execute SPI transfer
.wait		lda SPI_SS		; get transfer status
                bpl .wait		; wait until all 8 bits are sent
                lda SPI_DATA		; get reply byte from SPI data latch
                sta ZP_CMD_PKG,x	; store byte (one status byte, two data bytes)
                inx
                cpx #$03
                bne .nextByte		; repeat for all three bytes
                sta SPI_RESET		; end SPI transaction
                lda #$01
                jsr A2_WAIT		; wait 30 Âµs to give time for SPI EXECUTE pulse to finish
                rts
                
;----------------------------------------------------------------------------------------
; upload and verify - furnish length (ZP_LENH/L) and verify flag (ZP_VERIFY). 
; Returns with $FF in VERIFY if error, page index in LENL, A, Y and X scrambled.
;----------------------------------------------------------------------------------------
		SUBROUTINE
UploadVerify	lda #$00		; initialize pointers and page end
		sta .pageEnd+1
                lda #$04
                sta ZP_SRC_PTR
                lda #$20
                sta ZP_SRC_PTR+1
                
                lda ZP_LENH		; if less than one page, go right to final page
                beq .finalPage
.nextPage	ldy #$00
.pageLoop	lda ZP_VERIFY		; if verify set, verify, otherwise send
                bmi .verify
                
.send		lda (ZP_SRC_PTR),y	; data starts at $2000
		sta ZP_DATAH		
		iny 
                lda (ZP_SRC_PTR),y	; move hi and lo bytes into spi data storage
		sta ZP_DATAL
                lda #$90		; $90 = write command
                sta ZP_CMD_STAT		; move command into spi command storage
                jsr SPICmd		; execute spi transaction
                jmp .common

.verify		lda #$80		; $80 = read command
		sta ZP_CMD_STAT		; move command into spi command register
		jsr SPICmd		; execute spi transaction
                lda (ZP_SRC_PTR),y	
                cmp ZP_DATAH		; compare data bytes to what was read
                bne .error		; error if not the same
                iny
                lda (ZP_SRC_PTR),y
                cmp ZP_DATAL
                bne .error
                
.common         iny      
.pageEnd	cpy #$00		; check to see if done with page
		bne .pageLoop		; (including partial page)
		lda ZP_LENH
                beq .finalPage
                inc ZP_SRC_PTR+1	; add one to data pointer hi byte
                dec ZP_LENH
                jmp .nextPage		; read or verify next page
                
.finalPage	lda ZP_LENL		; if length lo byte is >0, put it in page_end compare
		beq .end
                sta .pageEnd+1
                lda #$00
                sta ZP_LENL		; zero out lo byte for next time
                jmp .nextPage		; and read or verify next (partial) page
                
.error		lda #$ff		; set error flag
		sta ZP_VERIFY
                sty ZP_LENL		; store current y reg for analysis
.end		rts
	
;----------------------------------------------------------------------------------------
; Monitor I/O - reads Spikpeutor buffer index and prints out any characters in it
;		will eventually handle special commands and graphics
;		exit on ESC being pressed, A, X, and Y scrambled
;----------------------------------------------------------------------------------------    
        	SUBROUTINE
Monitor_IO	jsr StopSpikeputor
                ldx #>SP_OUT_BUF_LCK
                lda #<SP_OUT_BUF_LCK
                jsr ReadAddress		; read buffer lock
                lda ZP_DATAH
                bne .restart		; if not zero, buffer is locked
 
                ldx #>SP_OUT_BUF_IDX
                lda #<SP_OUT_BUF_IDX
                jsr ReadAddress		; read buffer indeces
                lda ZP_DATAH
                cmp ZP_DATAL
                beq .restart		; if start index is the same as last open index, nothing to read
                
                sta ZP_BUF_IDXH		; save the buffer indeces
                lda ZP_DATAL
                sta ZP_BUF_IDXL
                
.bufLoop	ldx #>SP_OUT_BUF
		lda ZP_BUF_IDXH		; get index of first character in buffer = hi byte of buffer address
                jsr ReadAddress		; get next word from buffer
                lda ZP_DATAL		; get lo byte of character data (ascii)
                                        ; TODO: check for special characters
                                        ; TODO: handle input and graphics
                                        ; TODO: convert lower case to upper case
                jsr A2_COUT		; print the character
                lda ZP_BUF_IDXH
                clc
                adc #$02		; go to next index
                and #$7f		; wrap index around to $00 after $7f
                sta ZP_BUF_IDXH
                cmp ZP_BUF_IDXL		; check if next index is last open index
                bne .bufLoop
                
                ldx #>SP_OUT_BUF_IDX
                lda #<SP_OUT_BUF_IDX
                ldy #ZP_BUF_IDXH
                jsr WriteAddress	; write new buffer indeces
                
                			; check for keyboard interrupt
.restart	lda #$e0
		sta ZP_CMD_STAT
                jsr SPICmd		; restart Spikeputor
                lda #97
                jsr A2_WAIT		; delay ~25ms - about the time for Spikeputor to write a character to the buffer
                jmp Monitor_IO          ; loop
            	
;----------------------------------------------------------------------------------------
; WriteAddress - sets the Spikeputor address and writes the word. 
;		set X to ADDRH, A to ADDRL, Y to zero page address of word (big endian)
;		scrambles A, X and Y
;----------------------------------------------------------------------------------------
		SUBROUTINE
WriteAddress	stx ZP_DATAH
		sta ZP_DATAL
                lda #$a0
                sta ZP_CMD_STAT
                jsr SPICmd		; set address
                
                lda #$90
                sta ZP_CMD_STAT
                tya
                tax
                lda $00,x
                sta ZP_DATAH
                inx
                lda $00,x
                sta ZP_DATAL		; put data into CMD_PKG
                jsr SPICmd		; write data
                rts
		
;----------------------------------------------------------------------------------------
; ReadAddress - sets the Spikeputor address and reads the word. 
;		set X to ADDRH, A to ADDRL, scrambles A and X, data in ZP_CMD_PKG
;----------------------------------------------------------------------------------------  
		SUBROUTINE
ReadAddress  	stx ZP_DATAH
                sta ZP_DATAL
                lda #$a0
                sta ZP_CMD_STAT
                jsr SPICmd		; set address
                
                lda #$80
                sta ZP_CMD_STAT
                jsr SPICmd		; read data
                rts
                
;----------------------------------------------------------------------------------------
; StopSpikeputor - sends the Spikeputor a stop command and waits until it stops
;		 - A and X scrambled.
;----------------------------------------------------------------------------------------    
                SUBROUTINE
StopSpikeputor 	lda #$F0
                sta ZP_CMD_STAT
                jsr SPICmd		; stop Spikeputor
.waitForStop	lda #$80
 		sta ZP_CMD_STAT
                jsr SPICmd		; check to see that it is stopped
                lda ZP_CMD_STAT
                bmi .waitForStop	; if bit 7 is set, not yet stopped
		rts
                